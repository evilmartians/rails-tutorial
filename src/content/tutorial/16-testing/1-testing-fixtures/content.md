---
type: lesson
title: Testing & Fixtures
focus: /workspace/store/test/fixtures/products.yml
previews:
  - 3000
custom:
  shell:
    workdir: "/workspace/store"
---

### Testing

Rails comes with a robust test suite. Let's write a test to ensure that the correct number of emails are sent when a product is back in stock.

## Fixtures

When you generate a model using Rails, it automatically creates a corresponding fixture file in the `test/fixtures` directory.

Fixtures are predefined sets of data that populate your test database before running tests. They allow you to define records with easy-to-remember names, making it simple to access them in your tests.

This file will be empty by default - you need to populate it with fixtures for your tests.

Let's update the product fixtures file at `test/fixtures/products.yml` with the following:

```yaml
tshirt:
  name: T-Shirt
  inventory_count: 15
```

And for subscribers, let's add these two fixtures to `test/fixtures/subscribers.yml`:

```yaml
david:
  product: tshirt
  email: david@example.org

chris:
  product: tshirt
  email: chris@example.org
```

You'll notice that we can reference the `Product` fixture by name here. Rails associates this automatically for us in the database so we don't have to manage record IDs and associations in tests.

These fixtures will be automatically inserted into the database when we run our test suite.

## Testing Emails

In `test/models/product_test.rb`, let's add a test:

```ruby ins={2-12}
require "test_helper"

class ProductTest < ActiveSupport::TestCase
  include ActionMailer::TestHelper

  test "sends email notifications when back in stock" do
    product = products(:tshirt)
    # Set product out of stock
    product.update(inventory_count: 0)

    assert_emails 2 do
      product.update(inventory_count: 99)
    end
  end
end
```

Let's break down what this test is doing.

First, we include the Action Mailer test helpers so we can monitor emails sent during the test.

The `tshirt` fixture is loaded using the `products()` fixture helper and returns the Active Record object for that record. Each fixture generates a helper in the test suite to make it easy to reference fixtures by name since their database IDs may be different each run.

Then we ensure the tshirt is out of stock by updating it's inventory to 0.

Next, we use `assert_emails` to ensure 2 emails were generated by the code inside the block. To trigger the emails, we update the product's inventory count inside the block. This triggers the `notify_subscribers` callback in the Product model to send emails. Once that's done executing, `assert_emails` counts the emails and ensures it matches the expected count.

We can run the test suite with `bin/rails test` or an individual test file by passing the filename.

```bash
bin/rails test test/models/product_test.rb
```

Our test passes!

Rails also generated an example test for `ProductMailer` at `test/mailers/product_mailer_test.rb`. Let's update it to make it also pass.

```ruby ins={2-11}
require "test_helper"

class ProductMailerTest < ActionMailer::TestCase
  test "in_stock" do
    mail = ProductMailer.with(product: products(:tshirt), subscriber: subscribers(:david)).in_stock
    assert_equal "In stock", mail.subject
    assert_equal [ "david@example.org" ], mail.to
    assert_equal [ "from@example.com" ], mail.from
    assert_match "Good news!", mail.body.encoded
  end
end
```

Let's run the entire test suite now and ensure all the tests pass.

```bash
bin/rails test
```

You can use this as a starting place to continue building out a test suite with full coverage of the application features.

## Understanding Rails Testing

Rails testing provides:

1. **Test database** - Separate database for testing
2. **Fixtures** - Predefined test data
3. **Test helpers** - Utilities for common testing tasks
4. **Assertions** - Methods to verify expected behavior
5. **Integration testing** - Test complete user workflows

### Testing Best Practices

- **Test behavior, not implementation** - Focus on what the code does
- **Use descriptive test names** - Make tests self-documenting
- **Keep tests independent** - Each test should stand alone
- **Test edge cases** - Include boundary conditions
- **Maintain test data** - Keep fixtures simple and relevant

Testing gives you confidence that your code works correctly and helps prevent regressions as you add new features!